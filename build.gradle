import groovy.xml.*
import groovy.json.*
import groovy.xml.NamespaceBuilder

Properties privateProperties = new Properties()
privateProperties.load(new FileInputStream("private.sf.properties"))

ext {
    sfUsername = privateProperties.getProperty('sf.username')
    sfPassword = privateProperties.getProperty('sf.password') 
    gradleHome = System.getenv('GRADLE_HOME')
    sfLibPath = gradleHome + '/lib/ant-salesforce.jar'
}

ant.taskdef(
    resource: 'com/salesforce/antlib.xml',
    uri: 'antlib:com.salesforce',
    classpath: sfLibPath
)
def sfAnt = NamespaceBuilder.newInstance(ant, 'antlib:com.salesforce')

task generateFullPackageXml << {
    def folder = new File('temp')
    folder.mkdir()

    def metadataDescribe = new JsonSlurper()
        .parse(file(getProjectProperty('metadata.describe.location')))

    def metaMap = [:]
    def theNode = metadataDescribe.metadataObjects.each { meta ->
        if(meta.childXmlNames != null) {
            return
        }

        if(meta.xmlName == 'EmailTemplate') {
            return
        }

        def folders = [];
        if(meta.inFolder) {
            getListMetadata(sfAnt, meta.xmlName + 'Folder', 
                'temp/' + meta.directoryName + 'Folders', '')
            def metaFile = new File('temp/' + meta.directoryName + 'Folders')
            if(!metaFile.exists()) {
                return
            }
            metaFile.eachLine { line ->
                String s = 'FullName/Id:'
                if(line.startsWith(s)) {
                    def name = line.substring(s.size() + 1, line.indexOf('/', s.size()))
                    folders.add(name)
                }
            }
        } else {
            folders.add('')
        }

        folders.each{ folderName ->
            getListMetadata(sfAnt, meta.xmlName, 'temp/' + meta.directoryName, folderName) 
            def metaFile = new File('temp/' + meta.directoryName)
            if(!metaFile.exists()) {
                return
            }
            def listMeta = []
            metaFile.eachLine { line ->
                String s = 'FullName/Id:'
                if(line.startsWith(s)) {
                    def name = line.substring(s.size() + 1, line.indexOf('/', s.size()))
                    listMeta.add(name)
                }
            }
            metaMap.put(meta.xmlName, listMeta.toSet())
        }
    }
    String packageXml = createPackageXml(metaMap, false)
    println packageXml
}

task deployChanges(/*dependsOn: 'backup'*/) << {
    def stream = new ByteArrayOutputStream()
    def result = execGit('.', ['diff-tree', '--no-commit-id', '--name-status','-r', 
        getProjectProperty('git.commit.id.last'), 
        getProjectProperty('git.commit.id.first')], stream)
    String gitOutput = stream.toString()
    formatPrint('Changed files : \r\n' + gitOutput)
    
    def parseWrapper = parseGitOutput(gitOutput)
    def changedSourceFiles = parseWrapper.changedFiles
    def folderNameChangedFilesMap = parseWrapper.folderFilesMap
    def folderNameDeletedFilesMap = parseWrapper.filderDeletedFilesMap
    
    if (changedSourceFiles.size() == 0 && folderNameDeletedFilesMap.keySet().size() == 0) {
        formatPrint('There no changed files for deploy')
        return
    }

    def sourceAndItsMetadataFiles = addMetadataFilesToSources(changedSourceFiles)
    formatPrint('Changed Files For Deploy : \r\n' + sourceAndItsMetadataFiles)

    delete fileTree(dir: getProjectProperty('build.dir'))
    formatPrint('Delete Forlder : ' + getProjectProperty('build.dir'))

    copy {
        from getProjectProperty('src.dir')
        into getProjectProperty('build.dir')
        include sourceAndItsMetadataFiles
    }
    formatPrint('Copy Files From : ' + getProjectProperty('src.dir') + 
        ' To : ' + getProjectProperty('build.dir'))

    def currentSfApiVersion = getCurrentSfApiVersion()
    formatPrint('Current SF API Version : ' + currentSfApiVersion)

    if (folderNameDeletedFilesMap.keySet().size() > 0) {

        String antOutput = '';
        def metadataDescribe = new JsonSlurper()
            .parse(file(getProjectProperty('metadata.describe.location')))

        folderNameDeletedFilesMap.each { folder, listOfMetadata ->
            def theNode = metadataDescribe.metadataObjects
                        .find { it.directoryName == folder }
            getListMetadata(sfAnt, theNode.xmlName, 'listMetadata.log')
            antOutput += new File('listMetadata.log').text
        }

        def folderNameExistDeleteFilesMap = [:]

        folderNameDeletedFilesMap.each { folder, listOfMetadata ->
            listOfMetadata.each { metadataFile ->
                def folderWithMetadata = folder + '/' + metadataFile
                if (antOutput.contains(folderWithMetadata)) {
                    def metadataList = folderNameExistDeleteFilesMap.get(folder)
                    if (metadataList) {
                        metadataList.add(metadataFile)
                    } else{
                        metadataList = [metadataFile]
                    }
                    folderNameExistDeleteFilesMap.put(folder, metadataList)
                }
            }
        }

        if(folderNameExistDeleteFilesMap.keySet().size() == 0
        && changedSourceFiles.size() == 0) {
            return
        }

        if (folderNameExistDeleteFilesMap.keySet().size() > 0) {
            def destructiveChangesXmlString = createPackageXml(folderNameExistDeleteFilesMap, true)
            formatPrint('destructiveChnges.xml : \r\n' + destructiveChangesXmlString)

            def destructiveChangesXml = 
                new File(getProjectProperty('build.dir') + '/src/destructiveChanges.xml')
            destructiveChangesXml.text = destructiveChangesXmlString
        }
    }

    def packageXmlString = createPackageXml(folderNameChangedFilesMap, true)
    formatPrint('Package.xml : \r\n' + packageXmlString)

    def packageXml = new File(getProjectProperty('build.dir') + '/src/package.xml')
    packageXml.text = packageXmlString

    tasks.'deployMetadata'.execute()
}

task backup << {
    def backupDir = getProjectProperty('backup.dir')
    def backupPackageXml = getProjectProperty('backup.packageXml')
    def repositoryUrl = getProjectProperty('git.repository.url')
    def remote = getProjectProperty('git.remote.name')
    def backupBranch = getProjectProperty('git.backup.branch')
    def commitMsg = getProjectProperty('git.commit.backup.msg') + ' ' + new Date()

    def folder = new File(backupDir)
    if (!folder.exists()) {
        folder.mkdirs()
    } else {
        folder.deleteDir()
    }

    formatPrint('Cloning...')
    def result = execGit('.', ['clone', repositoryUrl, backupDir], null)

    def stream = new ByteArrayOutputStream()
    result = execGit(backupDir, ['branch', '-r'], stream)
    String gitOutput = stream.toString()

    formatPrint('Checkout to backup branch...')
    if (!gitOutput.contains(remote + '/' + backupBranch)) {
        result = execGit(backupDir, ['checkout', '-b', backupBranch], null)
    } else {
        result = execGit(backupDir, ['checkout', backupBranch], null)
    }

    formatPrint('Retrieve Metadata...')
    retrieveMetadataFromServer(sfAnt, backupDir + '/src', backupPackageXml)

    formatPrint('Add file to index...')
    result = execGit(backupDir, ['add', '-A'], null)

    formatPrint('Diffing...')
    gitOutput = ''
    stream = new ByteArrayOutputStream()
    result = execGit(backupDir, ['diff', 'HEAD', '--name-only'], stream)
    gitOutput = stream.toString()

    Boolean isAnyChanges = gitOutput != null && gitOutput.trim() != '';
    if (!isAnyChanges) {
        formatPrint('There are no chages. Backup is up to date.')
        return
    }

    formatPrint('Commit...')
    result = execGit(backupDir, ['commit', '-m', commitMsg], null)

    formatPrint('Push...')
    result = execGit(backupDir, ['push', 'origin', backupBranch], null)
}

def Expando parseGitOutput(String output) {
    def changedFiles = output.split('\\n')

    def changedSourceFiles = [];
    def folderNameChangedFilesMap = [:]
    def folderNameDeletedFilesMap = [:]

    changedFiles.each { changedFile ->

        // Possible Modifiers
        // ' ' = unmodified
        // M = modified
        // A = added
        // D = deleted
        // R = renamed
        // C = copied
        // U = updated but unmerged
        def modifier = changedFile.substring(0, 1)

        // Remove Modifier
        changedFile = changedFile.substring(1, changedFile.length()).trim()

        def filePath = changedFile.split('/')
        if (filePath.size() >= 3) {
            def metadataFolderName = filePath[1]

            def changedFilesInFolder = null
            if (modifier == 'D') {
                changedFilesInFolder = folderNameDeletedFilesMap.get(metadataFolderName)
            } else {
                changedFilesInFolder = folderNameChangedFilesMap.get(metadataFolderName)
            }

            def currentFile = filePath[filePath.size() - 1]
            if (currentFile.indexOf('-meta.xml') == -1) {
                def currentFileWithoutExtension = currentFile
                    .substring(0, currentFile.indexOf('.'))
                if (changedFilesInFolder) {
                    changedFilesInFolder.add(currentFileWithoutExtension)
                } else {
                    changedFilesInFolder = [ currentFileWithoutExtension ]
                }
                if (modifier == 'D') {
                    folderNameDeletedFilesMap.put(metadataFolderName, changedFilesInFolder)
                } else {
                    changedSourceFiles.add(changedFile)
                    folderNameChangedFilesMap.put(metadataFolderName, changedFilesInFolder)
                }
            }
        }
    }
    return new Expando( changedFiles : changedSourceFiles,
        folderFilesMap : folderNameChangedFilesMap,
        filderDeletedFilesMap : folderNameDeletedFilesMap);
}

def List<String> addMetadataFilesToSources(List<String> changedSourceFiles) {
    def sourceAndItsMetadataFiles = []
    for (def i in changedSourceFiles) {
        sourceAndItsMetadataFiles.add(i)
        sourceAndItsMetadataFiles.add(i + '-meta.xml')
    }
    return sourceAndItsMetadataFiles
}

def String getCurrentSfApiVersion() {
    def originalPackageXml = new XmlParser()
        .parse('src/package.xml')
    return originalPackageXml.get('version').text();
}

def String createPackageXml(Map<String, List<String>> folderNameChangedFilesMap, Boolean translateName) {
    def metadataDescribe = new JsonSlurper()
        .parse(file(getProjectProperty('metadata.describe.location')))

    def stringWriter = new StringWriter()
    def builder = new MarkupBuilder(stringWriter)
    builder.mkp.xmlDeclaration(version: "1.0", encoding: "UTF-8")
    builder.package('xmlns' : "http://soap.sforce.com/2006/04/metadata"){
        for(filderName in folderNameChangedFilesMap.keySet()) {
            types() {
                def files = folderNameChangedFilesMap.get(filderName)
                for(file in files) {
                    members(file)
                }
                String xmlName = '';
                if(translateName) {
                    def theNode = metadataDescribe.metadataObjects
                        .find { it.directoryName == filderName }
                    xmlName = theNode.xmlName
                } else {
                    xmlName = filderName
                }
                delegate.name(xmlName)
            }
        }
        delegate.version(currentSfApiVersion)
    }
    return stringWriter.toString()
}

def String getProjectProperty(String propertyName) {
    String customProprty = null
    if (hasProperty(propertyName)) {
        customProprty = this.properties[propertyName]
    }
    return customProprty
}

def String execGit(String gitWorkingDir, List<String> gitArgs, OutputStream output) {
    if (output == null) {
        output = System.out
    }
    return exec {
        workingDir = gitWorkingDir
        executable = 'git'
        args = gitArgs
        standardOutput = output
    }
}

def formatPrint(String message) {
    logger.quiet('')
    logger.quiet('==========================================')
    logger.quiet(message)
    logger.quiet('==========================================')
    logger.quiet('')
}

def captureAntOutput(ant, Closure command) {
    def buffer = new ByteArrayOutputStream()
    def captureStream = new PrintStream(buffer, true, "UTF-8")
    def listener = new org.apache.tools.ant.DefaultLogger(
        errorPrintStream: captureStream,
        outputPrintStream: captureStream,
        messageOutputLevel: org.apache.tools.ant.Project.MSG_INFO
    )

    ant.project.addBuildListener(listener)
    project.configure(ant, command)
    ant.project.removeBuildListener(listener)

    return buffer.toString("UTF-8");
}

def retrieveMetadataFromServer(sfAnt, String targetPath, String packageXmlPath) {
    sfAnt.retrieve(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        maxPoll : getProjectProperty('sf.maxPoll'), 
        retrieveTarget : targetPath, 
        unpackaged : packageXmlPath
    )
}

def getListMetadata(sfAnt, String metadataType, String resultPath) {
    sfAnt.listMetadata(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        metadataType : metadataType,
        resultFilePath : resultPath
    )
}

def getListMetadata(sfAnt, String metadataType, String resultPath, String folderName) {
    sfAnt.listMetadata(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        metadataType : metadataType,
        folder : folderName,
        resultFilePath : resultPath
    )
}

// Standard task

task retrieveMetadata << {
    sfAnt.retrieve(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        maxPoll : getProjectProperty('sf.maxPoll'), 
        retrieveTarget : getProjectProperty('sf.path.retrieveTarget'), 
        unpackaged : getProjectProperty('sf.path.packageXml')
    )
}

task deployMetadata << {
    sfAnt.deploy(
        serverurl : getProjectProperty('sf.serverurl'), 
        username : sfUsername,
        password : sfPassword,
        maxPoll : getProjectProperty('sf.maxPoll'), 
        deployRoot : getProjectProperty('sf.deployRoot'), 
        rollbackOnError : getProjectProperty('sf.rollbackOnError'), 
        checkOnly : getProjectProperty('sf.checkOnly'),
        runAllTests : getProjectProperty('sf.runAllTests')
    )
}
// <!-- logType="Debugonly" -->
// <!-- <runTest>SampleDeployClass</runTest> -->

task listMetadata << {
    sfAnt.listMetadata(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        folder : '',
        metadataType : getProjectProperty('sf.metadataType')
    )
}

task bulkRetrieve << {
    sfAnt.bulkRetrieve( 
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        maxPoll : getProjectProperty('sf.maxPoll'), 
        metadataType : getProjectProperty('sf.metadataType'), 
        retrieveTarget : getProjectProperty('sf.metadataDir')
    )
}

task describeMetadata << {
    sfAnt.describeMetadata(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'),
        resultFilePath : 'describe.log'
    )
}


tasks.each {
    task -> task.group = 'gres.sf'
}