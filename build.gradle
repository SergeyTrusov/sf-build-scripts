apply plugin: 'java'
apply plugin: 'groovy'

import groovy.xml.*
import groovy.json.*
import groovy.xml.NamespaceBuilder
import groovy.transform.ToString
import groovyx.net.http.HTTPBuilder

import static groovyx.net.http.Method.*
import static groovyx.net.http.ContentType.*

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath group: 'org.codehaus.groovy.modules.http-builder', name: 'http-builder', version: '0.7.1'
    }
}

Properties privateProperties = new Properties()
privateProperties.load(new FileInputStream("private.sf.properties"))

ext {
    sfUsername = privateProperties.getProperty('sf.username')
    sfPassword = privateProperties.getProperty('sf.password') 
    gradleHome = System.getenv('GRADLE_HOME')
    sfLibPath = gradleHome + '/lib/ant-salesforce.jar'
}

ant.taskdef(
    resource: 'com/salesforce/antlib.xml',
    uri: 'antlib:com.salesforce',
    classpath: sfLibPath
)
def sfAnt = NamespaceBuilder.newInstance(ant, 'antlib:com.salesforce')

task mytest << {
    println getEmailTemplates()
}

def getEmailTemplates() {
    def emailTemplates = []

    String sessionId = getSessionId().sessionId
    URI fullUri = new URI(getSessionId().url as String)

    def http = new HTTPBuilder("${fullUri.scheme}://${fullUri.host}")
    http.request(GET) { req ->
        uri.path = '/services/data/v33.0/tooling/query'
        uri.query = [q : 'Select id,FullName from EmailTemplate' ]
        headers.'Authorization' = "Bearer ${sessionId}"

        response.success = { resp, reader ->
            reader.records.each {
                emailTemplates.add(it.FullName)
            }
        }

        response.failure = { resp ->
            formatPrint('Get Email Templates request error')
        }
    }
    return emailTemplates
}

def Expando getSessionId() {
    def http = new HTTPBuilder('https://login.salesforce.com')

    String requestBody = 
    """
    <env:Envelope xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'>
        <env:Body>
            <sf:login xmlns:sf='urn:enterprise.soap.sforce.com'>
                <sf:username>${sfUsername}</sf:username>
                <sf:password>${sfPassword}</sf:password>
            </sf:login>
        </env:Body>
    </env:Envelope>
    """ 
    http.request(POST) { req ->
        uri.path = '/services/Soap/c/33.0'
        requestContentType = URLENC 
        headers.'Content-Type' = "text/xml"
        headers.'SOAPAction' = "login"
        body = requestBody

        response.success = { resp, reader ->
            return new Expando(sessionId : reader.Body.loginResponse.result.sessionId,
                url : reader.Body.loginResponse.result.serverUrl);
        }

        response.failure = { resp ->
            formatPrint('Session Id request error')
        }
    }
}

def getAvalibleMetadata(sfAnt) {
    String describeFileName = 'describe.log';

    getMetadataDescription(sfAnt, describeFileName)

    def describeFile = new File(describeFileName)
    if(!describeFile.exists()) {
        return
    }

    String XML_NAME = 'XMLName: '
    String DIR_NAME = 'DirName: '
    String SUFFIX = 'Suffix: '
    String HASMETAFILE = 'HasMetaFile: '
    String INFOLDER = 'InFolder: '
    String CHILDOBJECTS = 'ChildObjects: '

    List<MetadataType> sfMetadataList = new ArrayList<MetadataType>()
    MetadataType metaType;
    describeFile.eachLine { line, index ->
        if(line.startsWith('*****')) {
            if(index > 1) {
                sfMetadataList.add(metaType)
            }
            metaType = new MetadataType()
            return
        }

        if(line.startsWith(XML_NAME)) {
            metaType.xmlName = line.substring(XML_NAME.length())
        } else if(line.startsWith(DIR_NAME)) {
            metaType.dirName = line.substring(DIR_NAME.length())
        } else if(line.startsWith(SUFFIX)) {
            metaType.suffix = line.substring(SUFFIX.length())
        } else if(line.startsWith(HASMETAFILE)) {
            metaType.hasMetaFile = line.substring(HASMETAFILE.length()).toBoolean()
        } else if(line.startsWith(INFOLDER)) {
            metaType.inFolder = line.substring(INFOLDER.length()).toBoolean()
        } else if(line.startsWith(CHILDOBJECTS)) {
            def commaSeparatedValues = line.substring(CHILDOBJECTS.length())
            if(!commaSeparatedValues.contains(',')) {
                return
            }

            def childs = commaSeparatedValues.split(',')
            metaType.childObjects = childs.take(childs.size() - 1)
        }
    }
    return sfMetadataList
}

task generateFullPackageXml << {
    def avalibleMetadataList = getAvalibleMetadata(sfAnt)

    def folder = new File('temp')
    folder.mkdir()

    def metaTypeFilesMap = [:]
    avalibleMetadataList.each { metaType ->
        
        // if(metaType.childObjects != null) {
        //     return
        // }

        if(metaType.xmlName == 'EmailTemplate') {
            return
        }

        def folders = []
        if(metaType.inFolder) {
            getListMetadata(sfAnt, metaType.xmlName + 'Folder', 'temp/' + metaType.dirName, '')
            def metaFile = new File('temp/' + metaType.dirName)
            if(!metaFile.exists()) {
                return
            }
            metaFile.eachLine { line ->
                String s = 'FullName/Id:'
                if(line.startsWith(s)) {
                    def name = line.substring(s.size() + 1, line.indexOf('/', s.size()))
                    folders.add(name)
                }
            }
        } else {
            folders.add('')
        }

        folders.each { folderName ->
            getListMetadata(sfAnt, metaType.xmlName, 'temp/' + metaType.dirName, folderName) 
            def metaFile = new File('temp/' + metaType.dirName)
            if(!metaFile.exists()) {
                return
            }
            def listMeta = []
            metaFile.eachLine { line ->
                String s = 'FullName/Id:'
                if(line.startsWith(s)) {
                    def name = line.substring(s.size() + 1, line.indexOf('/', s.size()))
                    listMeta.add(name)
                }
            }
            metaTypeFilesMap.put(metaType.xmlName, listMeta.toSet())
        }
        
    }
    def packageXmlFile = new File('package.xml')
    packageXmlFile.text = createPackageXml(metaTypeFilesMap, false)
}

task deployChanges(/*dependsOn: 'backup'*/) << {
    def stream = new ByteArrayOutputStream()
    def result = execGit('.', ['diff-tree', '--no-commit-id', '--name-status','-r', 
        getProjectProperty('git.commit.id.last'), 
        getProjectProperty('git.commit.id.first')], stream)
    String gitOutput = stream.toString()
    formatPrint('Changed files : \r\n' + gitOutput)
    
    def parseWrapper = parseGitOutput(gitOutput)
    def changedSourceFiles = parseWrapper.changedFiles
    def folderNameChangedFilesMap = parseWrapper.folderFilesMap
    def folderNameDeletedFilesMap = parseWrapper.filderDeletedFilesMap
    
    if (changedSourceFiles.size() == 0 && folderNameDeletedFilesMap.keySet().size() == 0) {
        formatPrint('There no changed files for deploy')
        return
    }

    def sourceAndItsMetadataFiles = addMetadataFilesToSources(changedSourceFiles)
    formatPrint('Changed Files For Deploy : \r\n' + sourceAndItsMetadataFiles)

    delete fileTree(dir: getProjectProperty('build.dir'))
    formatPrint('Delete Forlder : ' + getProjectProperty('build.dir'))

    copy {
        from getProjectProperty('src.dir')
        into getProjectProperty('build.dir')
        include sourceAndItsMetadataFiles
    }
    formatPrint('Copy Files From : ' + getProjectProperty('src.dir') + 
        ' To : ' + getProjectProperty('build.dir'))

    def currentSfApiVersion = getCurrentSfApiVersion()
    formatPrint('Current SF API Version : ' + currentSfApiVersion)

    if (folderNameDeletedFilesMap.keySet().size() > 0) {

        String antOutput = '';
        def metadataDescribe = new JsonSlurper()
            .parse(file(getProjectProperty('metadata.describe.location')))

        folderNameDeletedFilesMap.each { folder, listOfMetadata ->
            def theNode = metadataDescribe.metadataObjects
                        .find { it.directoryName == folder }
            getListMetadata(sfAnt, theNode.xmlName, 'listMetadata.log')
            antOutput += new File('listMetadata.log').text
        }

        def folderNameExistDeleteFilesMap = [:]

        folderNameDeletedFilesMap.each { folder, listOfMetadata ->
            listOfMetadata.each { metadataFile ->
                def folderWithMetadata = folder + '/' + metadataFile
                if (antOutput.contains(folderWithMetadata)) {
                    def metadataList = folderNameExistDeleteFilesMap.get(folder)
                    if (metadataList) {
                        metadataList.add(metadataFile)
                    } else{
                        metadataList = [metadataFile]
                    }
                    folderNameExistDeleteFilesMap.put(folder, metadataList)
                }
            }
        }

        if(folderNameExistDeleteFilesMap.keySet().size() == 0
        && changedSourceFiles.size() == 0) {
            return
        }

        if (folderNameExistDeleteFilesMap.keySet().size() > 0) {
            def destructiveChangesXmlString = createPackageXml(folderNameExistDeleteFilesMap, true)
            formatPrint('destructiveChnges.xml : \r\n' + destructiveChangesXmlString)

            def destructiveChangesXml = 
                new File(getProjectProperty('build.dir') + '/src/destructiveChanges.xml')
            destructiveChangesXml.text = destructiveChangesXmlString
        }
    }

    def packageXmlString = createPackageXml(folderNameChangedFilesMap, true)
    formatPrint('Package.xml : \r\n' + packageXmlString)

    def packageXml = new File(getProjectProperty('build.dir') + '/src/package.xml')
    packageXml.text = packageXmlString

    tasks.'deployMetadata'.execute()
}

task backup << {
    def backupDir = getProjectProperty('backup.dir')
    def backupPackageXml = getProjectProperty('backup.packageXml')
    def repositoryUrl = getProjectProperty('git.repository.url')
    def remote = getProjectProperty('git.remote.name')
    def backupBranch = getProjectProperty('git.backup.branch')
    def commitMsg = getProjectProperty('git.commit.backup.msg') + ' ' + new Date()

    def folder = new File(backupDir)
    if (!folder.exists()) {
        folder.mkdirs()
    } else {
        folder.deleteDir()
    }

    formatPrint('Cloning...')
    def result = execGit('.', ['clone', repositoryUrl, backupDir], null)

    def stream = new ByteArrayOutputStream()
    result = execGit(backupDir, ['branch', '-r'], stream)
    String gitOutput = stream.toString()

    formatPrint('Checkout to backup branch...')
    if (!gitOutput.contains(remote + '/' + backupBranch)) {
        result = execGit(backupDir, ['checkout', '-b', backupBranch], null)
    } else {
        result = execGit(backupDir, ['checkout', backupBranch], null)
    }

    formatPrint('Retrieve Metadata...')
    retrieveMetadataFromServer(sfAnt, backupDir + '/src', backupPackageXml)

    formatPrint('Add file to index...')
    result = execGit(backupDir, ['add', '-A'], null)

    formatPrint('Diffing...')
    gitOutput = ''
    stream = new ByteArrayOutputStream()
    result = execGit(backupDir, ['diff', 'HEAD', '--name-only'], stream)
    gitOutput = stream.toString()

    Boolean isAnyChanges = gitOutput != null && gitOutput.trim() != '';
    if (!isAnyChanges) {
        formatPrint('There are no chages. Backup is up to date.')
        return
    }

    formatPrint('Commit...')
    result = execGit(backupDir, ['commit', '-m', commitMsg], null)

    formatPrint('Push...')
    result = execGit(backupDir, ['push', 'origin', backupBranch], null)
}

def Expando parseGitOutput(String output) {
    def changedFiles = output.split('\\n')

    def changedSourceFiles = [];
    def folderNameChangedFilesMap = [:]
    def folderNameDeletedFilesMap = [:]

    changedFiles.each { changedFile ->

        // Possible Modifiers
        // ' ' = unmodified
        // M = modified
        // A = added
        // D = deleted
        // R = renamed
        // C = copied
        // U = updated but unmerged
        def modifier = changedFile.substring(0, 1)

        // Remove Modifier
        changedFile = changedFile.substring(1, changedFile.length()).trim()

        def filePath = changedFile.split('/')
        if (filePath.size() >= 3) {
            def metadataFolderName = filePath[1]

            def changedFilesInFolder = null
            if (modifier == 'D') {
                changedFilesInFolder = folderNameDeletedFilesMap.get(metadataFolderName)
            } else {
                changedFilesInFolder = folderNameChangedFilesMap.get(metadataFolderName)
            }

            def currentFile = filePath[filePath.size() - 1]
            if (currentFile.indexOf('-meta.xml') == -1) {
                def currentFileWithoutExtension = currentFile
                    .substring(0, currentFile.indexOf('.'))
                if (changedFilesInFolder) {
                    changedFilesInFolder.add(currentFileWithoutExtension)
                } else {
                    changedFilesInFolder = [ currentFileWithoutExtension ]
                }
                if (modifier == 'D') {
                    folderNameDeletedFilesMap.put(metadataFolderName, changedFilesInFolder)
                } else {
                    changedSourceFiles.add(changedFile)
                    folderNameChangedFilesMap.put(metadataFolderName, changedFilesInFolder)
                }
            }
        }
    }
    return new Expando( changedFiles : changedSourceFiles,
        folderFilesMap : folderNameChangedFilesMap,
        filderDeletedFilesMap : folderNameDeletedFilesMap);
}

def List<String> addMetadataFilesToSources(List<String> changedSourceFiles) {
    def sourceAndItsMetadataFiles = []
    for (def i in changedSourceFiles) {
        sourceAndItsMetadataFiles.add(i)
        sourceAndItsMetadataFiles.add(i + '-meta.xml')
    }
    return sourceAndItsMetadataFiles
}

def String getCurrentSfApiVersion() {
    def originalPackageXml = new XmlParser()
        .parse('src/package.xml')
    return originalPackageXml.get('version').text();
}

def String createPackageXml(Map<String, List<String>> folderNameChangedFilesMap, Boolean translateName) {
    def metadataDescribe = new JsonSlurper()
        .parse(file(getProjectProperty('metadata.describe.location')))

    def stringWriter = new StringWriter()
    def builder = new MarkupBuilder(stringWriter)
    builder.mkp.xmlDeclaration(version: "1.0", encoding: "UTF-8")
    builder.package('xmlns' : "http://soap.sforce.com/2006/04/metadata"){
        for(filderName in folderNameChangedFilesMap.keySet()) {
            types() {
                def files = folderNameChangedFilesMap.get(filderName)
                for(file in files) {
                    members(file)
                }
                String xmlName = '';
                if(translateName) {
                    def theNode = metadataDescribe.metadataObjects
                        .find { it.directoryName == filderName }
                    xmlName = theNode.xmlName
                } else {
                    xmlName = filderName
                }
                delegate.name(xmlName)
            }
        }
        delegate.version(currentSfApiVersion)
    }
    return stringWriter.toString()
}

def String getProjectProperty(String propertyName) {
    String customProprty = null
    if (hasProperty(propertyName)) {
        customProprty = this.properties[propertyName]
    }
    return customProprty
}

def String execGit(String gitWorkingDir, List<String> gitArgs, OutputStream output) {
    if (output == null) {
        output = System.out
    }
    return exec {
        workingDir = gitWorkingDir
        executable = 'git'
        args = gitArgs
        standardOutput = output
    }
}

def formatPrint(String message) {
    logger.quiet('')
    logger.quiet('==========================================')
    logger.quiet(message)
    logger.quiet('==========================================')
    logger.quiet('')
}

def retrieveMetadataFromServer(sfAnt, String targetPath, String packageXmlPath) {
    sfAnt.retrieve(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        maxPoll : getProjectProperty('sf.maxPoll'), 
        retrieveTarget : targetPath, 
        unpackaged : packageXmlPath
    )
}

def getListMetadata(sfAnt, String metadataType, String resultPath) {
    sfAnt.listMetadata(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        metadataType : metadataType,
        resultFilePath : resultPath
    )
}

def getListMetadata(sfAnt, String metadataType, String resultPath, String folderName) {
    sfAnt.listMetadata(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        metadataType : metadataType,
        folder : folderName,
        resultFilePath : resultPath
    )
}

// Standard task

task retrieveMetadata << {
    sfAnt.retrieve(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        maxPoll : getProjectProperty('sf.maxPoll'), 
        retrieveTarget : getProjectProperty('sf.path.retrieveTarget'), 
        unpackaged : getProjectProperty('sf.path.packageXml')
    )
}

task deployMetadata << {
    sfAnt.deploy(
        serverurl : getProjectProperty('sf.serverurl'), 
        username : sfUsername,
        password : sfPassword,
        maxPoll : getProjectProperty('sf.maxPoll'), 
        deployRoot : getProjectProperty('sf.deployRoot'), 
        rollbackOnError : getProjectProperty('sf.rollbackOnError'), 
        checkOnly : getProjectProperty('sf.checkOnly'),
        runAllTests : getProjectProperty('sf.runAllTests')
    )
}
// <!-- logType="Debugonly" -->
// <!-- <runTest>SampleDeployClass</runTest> -->

task listMetadata << {
    sfAnt.listMetadata(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        folder : '',
        metadataType : getProjectProperty('sf.metadataType')
    )
}

task bulkRetrieve << {
    sfAnt.bulkRetrieve( 
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'), 
        maxPoll : getProjectProperty('sf.maxPoll'), 
        metadataType : getProjectProperty('sf.metadataType'), 
        retrieveTarget : getProjectProperty('sf.metadataDir')
    )
}

task describeMetadata << {
    sfAnt.describeMetadata(
        username : sfUsername, 
        password : sfPassword, 
        serverurl : getProjectProperty('sf.serverurl'),
        resultFilePath : 'describe.log'
    )
}

@ToString(includeNames=true)
class MetadataType {
    String xmlName
    String dirName
    String suffix
    Boolean hasMetaFile
    Boolean inFolder
    String[] childObjects
}

tasks.each {
    task -> task.group = 'gres.sf'
}